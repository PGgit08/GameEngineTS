import { GameObject } from "../ecs/GameObject";
import { Lifecycle } from "../Lifecycle";
import { RendererManager } from "../managers/RendererManager";
import { mat3 } from "gl-matrix";

/**
 * @classdesc
 * A GameObject that acts like a "canvas" through which the game is rendered. When created it is automatically added to the 
 * {@link RendererManager}. It implements the {@link Lifecycle} interface and its Lifecycle methods are called when the RendererManager's
 * Lifecycle methods are called. However, its {@link load} method is not only called during the loading period, but also whenever this Renderer 
 * is added into the RendererManager. The Renderer creates the {@link gl} context when loaded or seletected as current by the RendererManager.
 * 
 * @class Renderer
 * @extends GameObject
 * @implements Lifecycle
 * 
 * @param {string} name - The name of this Renderer.
 * @param {string} canvasId - The DOM id of this Renderer's canvas.
 */
export class Renderer extends GameObject implements Lifecycle {
    private _width: number;
    private _height: number;

    private _projectionMat: mat3;

    private _canvas: HTMLCanvasElement;
    private _canvasId: string;

    private _gl: WebGLRenderingContext;

    private _mouseOver: boolean;

    private _loaded: boolean = false;

    /**  @returns {number} The width of this Renderer. */
    get width(): number {
        return this._width;
    }

    /** @returns {number} The height of this Renderer. */
    get height(): number {
        return this._height;
    }

    /** @returns {string} The id of the canvas of this Renderer. */
    get canvasId(): string {
        return this._canvasId;
    }

    /** @returns {HTMLCanvasElement} The HTML canvas of this Renderer. */
    get canvas(): HTMLCanvasElement {
        return this._canvas;
    }

    /** @returns {WebGLRenderingContext} The WebGL context created by this canvas. */
    get gl(): WebGLRenderingContext {
        return this._gl;
    }

    /** @returns {mat3} The projection matrix generated by this Renderer. */
    get projectionMat(): mat3 {
        return this._projectionMat;
    }

    /** @returns {boolean} Whether the mouse is over the canvas or not. */
    get mouseOver(): boolean {
        return this._mouseOver;
    }

    /** @returns {DOMRect} The DOM rectangle defining this Renderer's canvas. */
    get box(): DOMRect {
        return this._canvas.getBoundingClientRect();
    } 

    constructor(name: string, canvasId: string){
        super(name);

        this._canvasId = canvasId;

        RendererManager.getInstance().addRenderer(this);
    }

    // build this renderer from a supplied canvas
    private fromCanvas(): void {
        this._canvas = document.getElementById(this._canvasId) as HTMLCanvasElement;

        this._width = this._canvas.width;
        this._height = this._canvas.height;

        this._canvas.style.width = this._canvas.width.toString();
        this._canvas.style.height = this._canvas.height.toString();

        this._canvas.onmouseover = () => {
            this._mouseOver = true;
        };

        this._canvas.onmouseout = () => {
            this._mouseOver = false;
        }
    }

    /**
     * A method that creates a 600x800 canvas element and adds it to the DOM.
     * 
     * @static
     * 
     * @param {string} id - The desired id of the canvas.
     * 
     * @returns The Canvas.
     */
    public static CreateCanvas(id: string): HTMLCanvasElement {
        const canvas: HTMLCanvasElement = document.createElement("canvas") as HTMLCanvasElement;

        canvas.id = id;

        canvas.width = 800;
        canvas.height = 600;

        canvas.style.border = "thick solid #0000FF"; 

        canvas.style.width = canvas.width.toString();
        canvas.style.height = canvas.height.toString();

        document.body.appendChild(canvas);

        return canvas;
    }

    public load(): void {
        if (this._loaded) return;

        this.fromCanvas();
    
        this._gl = this._canvas.getContext("webgl") as WebGLRenderingContext;

        // some magic that recognizes transparency in a texture
        this._gl.enable(this._gl.BLEND);
        this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);

        if (this._gl === undefined) {
            throw new Error("Browser does not support WebGL");
        }

        this._projectionMat = mat3.fromValues(
            2 / this._width, 0, 0, // column 1 (scale X by 2/width, translate by -1)
            0, -2 / this._height, 0, // column 2 (scale Y by 2/height translate by 1)
            -1, 1, 1 // column 3 (NONE)
        );

        this._gl.clearColor(0.0, 0.0, 0.0, 0.0); // Set to white with transparent background
        this._gl.clear(this._gl.COLOR_BUFFER_BIT);
        this._gl.viewport(0, 0, this._gl.canvas.width, this._gl.canvas.height);

        this._loaded = true;
    }

    public update(): void {}

    public render(): void {
        this._gl.clear(this._gl.COLOR_BUFFER_BIT);
    }
}
